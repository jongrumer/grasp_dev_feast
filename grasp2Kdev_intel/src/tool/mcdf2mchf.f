      PROGRAM mcdf2mchf
      IMPLICIT NONE
!***********************************************************************
! Grant and Cowan use 'real' P(r)=r.R(r)
! Froese Fischer and Chernyesheva use:
! P_(r)= P(r)*sqrt(alpha+beta/r)
! FF: alpha=0, beta=1, so P_ff=P(r)/sqrt(r)
! E_gr=0.5*E_cw
! E_ff=    E_cw=EHF()
! E_ch=   -E_cw
!***********************************************************************
!xhh:
! rwfn.inp has the same format as the rwfn.out created by WRTRWF of
! the package ERWF.f
!
! The algorithm is
!
!   For each orbital nl
!      read the r-grid [rg(npts)]
!      read P_nk(r) and Q_nk(r) for j=l+1/2 and, if l>0, l-1/2
!      do 
!         P_nlj(r)^2 = P_nk(r)^2 + Q_nk(r)^2   for each j-component
!         P_nl(r)^2  = [ (2l+2) P_nlj+(r)^2 + 2l P_nlj-(r)^2 ] / (4l+2)
!                 or = P_nlj(r)^2  (if l=0)
!         P_nl(r)^2 -> P_nl(r)
!         Interpolation
!         P_nl(r) -> P_nl(r) / sqrt(r)
!
!***********************************************************************

      INTEGER   NWF, NPT, NPTS0, SIZE_OF_SYM
      PARAMETER (NWF=60, NPT=220, NPTS0=500, SIZE_OF_SYM=3)

      LOGICAL Iexist, positive_first
      INTEGER nn, ll, laky, npts, npt2, nwf1, nskip,lskip,nptskip,iorb,j
     &       ,nnodes, minsame, minpos
      INTEGER spaces_or_zeros
      DATA    spaces_or_zeros/ 1/  ! either 1 or 2 

      CHARACTER title*6, inputfile*8, outputfile*7
      CHARACTER atom*6, term*6, orbital*(SIZE_OF_SYM)

      DOUBLE PRECISION pf(NPT), rf(NPT), yy2(NPT)
      DOUBLE PRECISION pg(NPTS0,2), qg(NPTS0,2), rg(NPTS0), pgg(NPTS0)
      DOUBLE PRECISION Zatom, ener, ekin, a0, rho, hff
     &               , wtj_plus, wtj_minus, zero,one,four,sixteen
      DATA             zero,one,four,sixteen/0.d0,1.d0,4.d0,16.d0/
      DOUBLE PRECISION enerskip, a0skip, rgskip

************************************************************************
!23456789012345678901234567890123456789012345678901234567890123456789012

      inputfile = 'rwfn.inp'
      outputfile = 'wfn.inp'

      WRITE(*,*) '  ==============='
      WRITE(*,*) '    MCDF to MCHF'
      WRITE(*,*) '  ==============='
      WRITE(*,*)
      WRITE(*,*) ' Input:  ', inputfile
      WRITE(*,*)
      WRITE(*,*) ' Output:  ', outputfile
      WRITE(*,*)

! inquire file

      INQUIRE (FILE=inputfile,EXIST=Iexist)
      IF ( .NOT. Iexist) THEN
         WRITE(*,*) ' Input-file ', inputfile, ' does not exist'
         STOP
      ENDIF

! extra input

      WRITE(*,*) 'The input file ', inputfile, ' does not provide Z,',
     &          ' ATOM, and TERM'
      WRITE(*,*) ' atom ? (*6)'
      READ(*,*) atom
      WRITE(*,*) ' term ? (*6)'
      READ(*,*) term
      WRITE(*,*) ' Zatom ? (double precision)'
      READ(*,*) Zatom

! Construct MCHF grid

      rho = -four
      hff = one/sixteen
      rf(1) = zero
      DO j = 2, NPT
         rf(j) = EXP(rho)/Zatom
         rho = rho + hff
      ENDDO

! Open files for read and write

      OPEN(3,FILE=inputfile,STATUS='OLD',FORM='UNFORMATTED')
      OPEN(4,FILE=outputfile,STATUS='UNKNOWN',FORM='UNFORMATTED')

      READ(3) title

      IF (title .NE. 'G92RWF') THEN   ! Extra safety
         PRINT *, 'title = ', title, 'does not match G92RWF'
         STOP
      ENDIF

!***********************************************************************
!
!     The grid generated by the following call is not the same as that
!     read from the data of the grasp run (erwf)
!
!      CALL grid(Zatom,rg)
!      WRITE(*,*) (rg(j), j=1,230)
!
!***********************************************************************

      Orbitals: DO iorb = 1, nwf

         READ(3, END = 20) nn, laky, ener, npts
         IF (npts .GT. NPTS0) THEN
            WRITE(*,*) 'df2hf: npts .GT. NPTS0'
            STOP
         ENDIF
         READ(3) a0, (pg(j,1), j=1,npts), (qg(j,1), j=1,npts)
         READ(3) (rg(j), j=1,npts)

!**************
! Debug output

         IF (iorb.LT.10) THEN
            WRITE(iorb+10,*) '#  npts,  nn,  laky,  ener'
            WRITE(iorb+10,*) '#', npts, nn, laky, ener
            DO j = 1, npts
               WRITE(iorb+10,*) rg(j), pg(j,1), qg(j,1)
            ENDDO
         ENDIF
!**************

         IF (laky .GT. 0) THEN
            ll = laky

            ! Read the 2nd (higher j) component, may stop here if this
            ! is the last orbital which may have not been computed

            READ(3, END=20) nskip, lskip, enerskip, nptskip
            READ(3) a0skip, (pg(j,2), j=1,nptskip), 
     &               (qg(j,2), j=1,nptskip)
            READ(3) (rgskip, j=1, nptskip)
            IF (npts .NE. nptskip) THEN
              PRINT *, 'The No. of points for the two j-components ',
     &                 'are not the same'
              PRINT *, 'Using the smaller one...'
              npts = MIN(npts,nptskip)
            ENDIF

!**************
! Debug output

            IF (iorb.LT.10) THEN
               WRITE(iorb+20,*) '#  npts,  nn,  laky,  ener'
               WRITE(iorb+20,*) '#', nptskip, nn, laky, ener
               DO j = 1, nptskip
                  WRITE(iorb+20,*) rg(j), pg(j,2), qg(j,2)
               ENDDO
            ENDIF
!**************

         ELSEIF (laky .EQ. -1) THEN
            ll = -laky - 1
         ELSE
            WRITE(*,*)'Unexpected case in reading MCDF file- ',inputfile
            STOP
         ENDIF

! Convert the large and the small components of the radial wavefunctions
! to non-relativistic functions. Store in array pgg(j)

         DO j = 1, npts
            pgg(j) = pg(j,1)*pg(j,1) + qg(j,1)*qg(j,1)
         ENDDO

         IF (ll .NE. 0) THEN
            wtj_plus = (ll+one)/(2*ll+one)
            wtj_minus = ll/(2*ll+one)
            DO j = 1, npts
               pgg(j) = wtj_minus * pgg(j) + 
     &                  wtj_plus * (pg(j,2)*pg(j,2) + qg(j,2)*qg(j,2))
            ENDDO
         ENDIF

!**************
! Debug output
         DO j = 1, npts
            WRITE(iorb+30,*) rg(j), pgg(j)
         ENDDO
!**************

! Recover the wavefunction from its squared values

         positive_first = .TRUE.
         CALL sq2ori(positive_first,npts,rg,pgg,nnodes,minsame,minpos)
         PRINT *
         PRINT *, 'nn,  ll,  nnodes,   minsame,   minpos'
         PRINT *, nn,  ll,  nnodes,   minsame,   minpos

!**************
! Debug output
         DO j = 1, npts
            WRITE(iorb+40,*) rg(j), pgg(j), pgg(j)**2
         ENDDO
!**************

! Do the interpolation

         PRINT *
         PRINT *
         PRINT *, ' Deduce HF radial function from DF ones '
         PRINT *
         PRINT *

         IF (ll .EQ. 0) THEN
            CALL spline(rg, pgg, npts, a0, zero, yy2)
         ELSE
            CALL spline(rg, pgg, npts, zero, zero, yy2)
         ENDIF

         pf(1) = zero
         j = 2
         DOWHILE (j.LE.NPT .AND. rf(j).LE.rg(npts))

            CALL splint(rg, pg(1,1), yy2, npts, rf(j), pf(j))

            pf(j) = pf(j)/sqrt(rf(j))
            j = j + 1
         ENDDO
         npt2 = j - 1

! Form the symbol (line) by nn and ll

         CALL nl2sym(nn, ll, orbital, size_of_sym, spaces_or_zeros)

! Note: ekin is still undefined here

         WRITE(4) atom, term, orbital, npt2, Zatom, ener*2, ekin, a0,
     &             (pf(j), j=1,npt2)

         WRITE(*,*) nn, ll
         WRITE(*,*) atom, term, orbital, npt2, Zatom, ener*2, ekin, a0
!*************
! Debug output
         IF (iorb .LT. 10) THEN

            WRITE(iorb+50,*) '#  npt2, atom, term, orbital '
            WRITE(iorb+50,*) '#', npt2, atom, term, orbital

            DO j = 1, npt2
               WRITE(iorb+50,*) rf(j), pf(j)
            ENDDO

            DO j = 1, npts
               WRITE(iorb+60,*) rg(j), pgg(j)
            ENDDO

         ENDIF
!**************

      ENDDO Orbitals
   20 CONTINUE
      CLOSE(3)
      CLOSE(4)
      STOP
      END

! newroutine begins here grid
      subroutine GRID(z,rr)
*
      IMPLICIT REAL*8(A-H,O-Z) 
      DIMENSION RR(230)

      RNT = EXP (-65.0D 00/16.0D 00) / z
      H = 0.5D 00**4
      N = MIN (220,400)
      NP10 = N+10
      RR(1) = 0.0D 00
      EPH = EXP (H)
      ETT = 1.0D 00
*
*   Set up the arrays R, RP, RPOR
*
      DO 1 I = 2,NP10
         ETT = EPH*ETT
         ETTM1 = ETT-1.0D 00
         RR(I) = RNT*ETTM1
 1    CONTINUE
      return
      end
!NewPage !^L
! new routine begins here sq2ori
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!                     sq2ori
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE sq2ori(positive_first,npt,xx,yy,nnodes,minsame,minpos)
      IMPLICIT NONE
!$Id: mcdf2mchf.f,v 1.1.1.1 2003/01/04 21:45:39 georgio Exp $
!$Log: mcdf2mchf.f,v $
!Revision 1.1.1.1  2003/01/04 21:45:39  georgio
!import all
!
!Revision 1.1  1997/01/09 20:22:43  xhh
!Initial revision
!
      CHARACTER*(*)    RCSID
      PARAMETER        ( RCSID
     & ='$Id: mcdf2mchf.f,v 1.1.1.1 2003/01/04 21:45:39 georgio Exp $'
     & )
      LOGICAL positive_first
      INTEGER npt, nnodes, minpos, minsame
      DOUBLE PRECISION xx(npt), yy(npt)
      INTRINSIC SQRT
      EXTERNAL  abc_coef
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! This subroutine "recovers" the original function from its squared
! values based on the assumption that the function changes its sign
! wherever it passes a zero point. Obviously, the input function must
! be tabulated at a dense mesh.
!
! The program does not take any action toward the behavior of the
! input function. But it does give some info for reference:
!
! Inputs
!
!   positive_first 
!           - .true. then take the + sign from the start point
!             .false. then negative ...
!   npt     - The number of the tabulated points
!
! Inputs and outputs
!
!   a       - On input, the squared function;
!             on output, the recovered function
! Outputs
!
!   nnodes  - The number of nodes
!   minsame - The minimum number of points between two nodes
!             minpos-1 and minpos
!   minpos  - Ref minsame above. Obviously it must be .le. nnodes
!
! xh Wed Jan  8 17:25:52 CST 1997
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      INTEGER i, nsame
      DOUBLE PRECISION y1,y2,y3,x1,x2,x3,a,b,c,xmiddle,sign, one
      DATA             one/1.D0/

! Determine the star-up sign of the function by the input logical 

      IF (positive_first) THEN
         sign = one
      ELSE
         sign = - one
      ENDIF

      nsame = 0
      nnodes = 0
      minsame = 32767

      y1 = yy(1)
      yy(1) = sign * SQRT(yy(1))

      DO i = 2, npt-1, 1

         y2 = yy(i)
         y3 = yy(i+1)
         x1 = xx(i-1)
         x2 = xx(i)
         x3 = xx(i+1)

         IF ( y2.LT.y1 .AND. y2.LT.y3 ) THEN

! Care about the current point

            CALL abc_coef(x1,x2,x3,y1,y2,y3,a,b,c)
            xmiddle = -b/(2*a)

            y1 = yy(i)

            IF (x2 .LT. xmiddle) THEN
               yy(i) = sign * SQRT(yy(i))
               sign = -sign
            ELSE
               sign = -sign
               yy(i) = sign * SQRT(yy(i))
            ENDIF

! Care ends here

            nnodes = nnodes + 1
            IF (nsame .LT. minsame) THEN
               minsame = nsame
               nsame = 0
               minpos = nnodes
            ENDIF
         ELSE
            nsame = nsame + 1
            y1 = yy(i)
            yy(i) = sign * SQRT(yy(i))
         ENDIF

      ENDDO

      yy(npt) = sign * SQRT(yy(npt))

      RETURN
      END
!NewPage ! 
! new routine begins here abc_coef
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!                     abc_coef
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE abc_coef(x1,x2,x3,y1,y2,y3,a,b,c)
      IMPLICIT NONE
!$Id: mcdf2mchf.f,v 1.1.1.1 2003/01/04 21:45:39 georgio Exp $
!$Log: mcdf2mchf.f,v $
!Revision 1.1.1.1  2003/01/04 21:45:39  georgio
!import all
!
      CHARACTER*(*)    RCSID
      PARAMETER        ( RCSID
     & ='$Id: mcdf2mchf.f,v 1.1.1.1 2003/01/04 21:45:39 georgio Exp $'
     & )
      DOUBLE PRECISION x1,x2,x3,y1,y2,y3,a,b,c
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
! Obtain a,b,c from equations 
!
!   y_i = a*x_i^2 + b*x_i + c  ,  for i=1,3 
! 
! 
! 
!
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      DOUBLE PRECISION yx21,yx32,yx31, half
      DATA             half/0.5D0/
!
      yx21 = (y2-y1) / (x2-x1)
      yx32 = (y3-y2) / (x3-x2)
      yx31 = (y3-y1) / (x3-x1)

      a = (yx32-yx21) / (x3-x1)
      b = yx21 - a*(x2+x1) !or yx32 - a*(x3+x2)
      !b = half * (yx21 - a*(x2+x1) + yx32 - a*(x3+x2) )
      c = y1 - x1*(b+a*x1)

      RETURN
      END


      SUBROUTINE spline(x,y,n,yp1,ypn,y2)
      INTEGER n,NMAX
      DOUBLE PRECISION yp1,ypn,x(n),y(n),y2(n)
      PARAMETER (NMAX=500)
      INTEGER i,k
      DOUBLE PRECISION p,qn,sig,un,u(NMAX)
      if (yp1.gt..99d30) then
        y2(1)=0.d0
        u(1)=0.d0
      else
        y2(1)=-0.5d0
        u(1)=(3.d0/(x(2)-x(1)))*((y(2)-y(1))/(x(2)-x(1))-yp1)
      endif
      do 11 i=2,n-1
        sig=(x(i)-x(i-1))/(x(i+1)-x(i-1))
        p=sig*y2(i-1)+2.d0
        y2(i)=(sig-1.d0)/p
        u(i)=(6.d0*((y(i+1)-y(i))/(x(i+
     *1)-x(i))-(y(i)-y(i-1))/(x(i)-x(i-1)))/(x(i+1)-x(i-1))-sig*
     *u(i-1))/p
11    continue
      if (ypn.gt..99d30) then
        qn=0.d0
        un=0.d0
      else
        qn=0.5d0
        un=(3.d0/(x(n)-x(n-1)))*(ypn-(y(n)-y(n-1))/(x(n)-x(n-1)))
      endif
      y2(n)=(un-qn*u(n-1))/(qn*y2(n-1)+1.d0)
      do 12 k=n-1,1,-1
        y2(k)=y2(k)*y2(k+1)+u(k)
12    continue
      return
      END


      SUBROUTINE splint(xa,ya,y2a,n,x,y)
      INTEGER n
      DOUBLE PRECISION x,y,xa(n),y2a(n),ya(n)
      INTEGER k,khi,klo
      DOUBLE PRECISION a,b,h
      klo=1   ! One
      khi=n
1     if (khi-klo.gt.1) then
        k=(khi+klo)/2
        if(xa(k).gt.x)then
          khi=k
        else
          klo=k
        endif
      goto 1
      endif
      h=xa(khi)-xa(klo)
      if (h.eq.0.d0) pause 'bad xa input in splint'
      a=(xa(khi)-x)/h
      b=(x-xa(klo))/h
      y=a*ya(klo)+b*ya(khi)+((a**3-a)*y2a(klo)+(b**3-b)*y2a(khi))*(h**
     *2)/6.d0
      return
      END


!NewPage !^L
! new routine begins here nl2sym
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!                     nl2sym
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE nl2sym(n, l, sym, size_of_sym, spaces_or_zeros)
      IMPLICIT NONE
!$Id: mcdf2mchf.f,v 1.1.1.1 2003/01/04 21:45:39 georgio Exp $
!$Log: mcdf2mchf.f,v $
!Revision 1.1.1.1  2003/01/04 21:45:39  georgio
!import all
!
!Revision 1.1  1997/01/09 20:18:44  xhh
!Initial revision
!
      CHARACTER*(*)    RCSID
      PARAMETER        ( RCSID
     & ='$Id: mcdf2mchf.f,v 1.1.1.1 2003/01/04 21:45:39 georgio Exp $'
     & )
      INTEGER n, l, size_of_sym, spaces_or_zeros
      CHARACTER*(*) sym
      EXTERNAL convrt, l2sym
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
! This subroutine returns the sym, as an electron orbital described by
! the principal quantum number n and the orbital angular momentum number
! l. 
! For example, n=20, l=2, size_of_sym=4 would result in sym = 
!              '20d ' --- if spaces_or_zeros=1 ; and
!              '020d' --- if spaces_or_zeros=2 .
!
! This routine calls 
!   -- convrt to convert an integer to a string with length parameter
!             determined by the input integer parameter.
!   -- l2sym  to convert orbital angular momentum number 
!             l (0, 1, 2,...) to a symbol (s, p, d,...)
!
! By Xinghong He Mon Dec 30 16:46:56 CST 1996
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      INTEGER nlength, i
      CHARACTER*1 chl
!      CHARACTER*(*) chn
      CHARACTER*3 chn      ! Normally, this should be large enough
                           ! Anyway, convrt checks chn and n

      CALL convrt(n, chn, nlength)

      IF (nlength .GE. size_of_sym) THEN
         WRITE(*,*) 'nl2sym: size_of_sym too small'
         WRITE(*,*) 'size_of_sym = ', size_of_sym, '  nn = ', n
         STOP
      ENDIF

      CALL l2sym(l, chl)

      IF (spaces_or_zeros .EQ. 1) THEN
!
!        The following choice fills the tailling spaces with ' 's
!        which is the default setting in string operations
!
         sym(1 : nlength+1 ) = chn(1:nlength) // chl
         DO i = nlength+2, size_of_sym
            sym(i:i) = ' '
         ENDDO
         ! The above 4 lines are equivalent to the following 1 statement
         ! But better keep them since initialization is machine-dependent
         !sym = chn(1:nlength) // chl

         !sym = chn // chl   ! Gives wrong answer !!!

      ELSEIF (spaces_or_zeros .EQ. 2) THEN
!
!        The following choice fills the preceeding spaces with '0's
!        which is good for file-naming and ordering
!
         sym(size_of_sym-nlength : size_of_sym) = chn(1:nlength) // chl
         DO i = 1, size_of_sym - nlength - 1
            sym(i:i) = '0'
         ENDDO
      ELSE
         WRITE(*,*) 'nl2sym: spaces_or_zeros must be either 1 or 2'
         STOP
      ENDIF

      RETURN
      END

!NewPage !^L
! new routine begins here l2sym
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!                     l2sym
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE l2sym(l, sym)
      IMPLICIT NONE
!$Id: mcdf2mchf.f,v 1.1.1.1 2003/01/04 21:45:39 georgio Exp $
!$Log: mcdf2mchf.f,v $
!Revision 1.1.1.1  2003/01/04 21:45:39  georgio
!import all
!
!Revision 1.1  1997/01/09 20:16:08  xhh
!Initial revision
!
      CHARACTER*(*)    RCSID
      PARAMETER        ( RCSID
     & ='$Id: mcdf2mchf.f,v 1.1.1.1 2003/01/04 21:45:39 georgio Exp $'
     & )
      INTEGER l
      CHARACTER*(*) sym
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! Too simple to be commented
!
! By Xinghong He Mon Dec 30 15:54:38 CST 1996
!
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      CHARACTER*1 symlst(0:10)
      DATA symlst /'s','p','d','f','g','h','i','k','l','m','n'/

      IF (l .GT. 10) THEN
         WRITE(*,*) 'L is too big to be accommodated in l2sym'
         STOP
      ENDIF

      sym = symlst(l)

      RETURN
      END

************************************************************************
*                                                                      *
      SUBROUTINE CONVRT (INTNUM,CNUM,LENTH)
*                                                                      *
*   Converts the  INTEGER number  INTNUM  into the  CHARACTER string   *
*   CNUM of length LENTH. INTEGER lengths of up to 64 bits are acco-   *
*   modated.                                                           *
*                                                                      *
*   Written by Farid A. Parpia            Last revision: 22 Sep 1992   *
*                                                                      *
************************************************************************
*
      CHARACTER*(*) CNUM
      CHARACTER*6 FORM
      CHARACTER*2 C1020
      CHARACTER*1 C19
*
      DIMENSION C19(1:9)
      DIMENSION C1020(0:10)
*
      DATA C19   /      '1', '2', '3', '4', '5', '6', '7', '8', '9'/
      DATA C1020 /'10','11','12','13','14','15','16','17','18','19',
     :            '20'/
*
      IF     (INTNUM .LT. 0) THEN
         LENTH = LOG10 (DBLE (-INTNUM))+2
      ELSEIF (INTNUM .EQ. 0) THEN
         LENTH = 1
      ELSE
         LENTH = LOG10 (DBLE ( INTNUM))+1
      ENDIF
*
*   Ensure that the length of CNUM as dimensioned is adequate;
*   stop with an error message if it isn't
*
      IF (LENTH .GT. LEN (CNUM)) THEN
         PRINT *, 'CONVRT: Length of CNUM inadeuate.'
         STOP
      ELSE
         IF (LENTH .LE. 9) THEN
            FORM = '(1I'//C19(LENTH)//')'
            WRITE (CNUM(1:LENTH),FORM(1:5)) INTNUM
         ELSE
            FORM = '(1I'//C1020(LENTH-10)//')'
            WRITE (CNUM(1:LENTH),FORM(1:6)) INTNUM
         ENDIF
      ENDIF
*
      RETURN
      END
